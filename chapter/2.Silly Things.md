# 愚蠢的错误

> 哎呀！我又做了一次。

> Birtney Spears.


我有一箩筐的愚蠢的错误，不相关的劣质决策，这些简单的错误我犯了一遍又一遍，并且通常我都没有意识到。这些错误异常的消耗时间，在本章，我们将看一些我常常犯的愚蠢的错误。


-------------------------


## 忘记返回（一个）值

我相当确定，大量的时间花费在debug那些神秘的问题，然而，这些神秘的问题却由一个小小的错误引发：忘记从函数返回一个值。在没有显式`retrun`的时候，Python通常会返回一个`None`。 这样做很优雅并且很Pythonic，但是这同时是我最主要的窘迫之一。这通常发生在我快速开发的时候（也有可能我太懒惰而没有写测试）――我急于求成，但在我已经返回了这个值。


我主要是前端开发，当我遇到这个问题的时候，它往往已经深入到底层，比如存取数据到数据库。通过使用正确的`join`，最好的索引，让数据库查询清晰有条理，这是最有趣的部分。


我这有一个新鲜的例子，来自于我最近的工作。这个函数为投票者进行查询，根据投票日期将投票中整合。


```
def get_recent_voters(self, start_data=None, end_date=None):
	query = self.session.query(Voter).\
			join(Ballot).\
			filter(Voter.status.in_['A', 'P']))
	if start_date:
		query.filter(Ballot.election_date >= start_date)
	if end_date:
		query.filter(Ballot.election_date <= end_date)
	query.group_by(Voter.id)
	voters = query.all()
```

同时，这是一个3层或4层的栈，当那些遍历Voter对象列表的代码片段，得到一个`None`的时候，将是灾难性的结果。如果我擅长写测试，并且我也只写了这一个函数，那么我会不费吹灰之力修复这个错误。但是我已经专注了几个小时，又或者写了这个函数，一两天之后才运行这个函数，之后得到`AttributeError`或者`TypeError`是相当令人沮丧的。这个错误我可能已经犯了长百上千此，*如今这看起来已经是正确的*。我清楚地知道这意味着什么，并且这会妨碍我尽快找到错误。


有时期待函数返回`None`，或者函数结果通过了测试，这种隐含的的错误甚至更糟。在此情况下，我们甚至没有得到异常，相反是逻辑不太正确，又或者调用函数好像没有什么结果，尽管我们知道应该有所结果。调试这些错误是相当的痛苦和耗时的，并且存在一个很大的风险：只有到了代码的生命期的后期，这些错误才被触发。


我已经开始同这项癖好做斗争。方法是培养在定义函数之后马上写`return`语句，之后再写函数的核心部分的习惯。


```
def get_recent_voters(self, start_data=None, end_date=None):
	voters = []
	# TODO: go get the data, sillycakes
	return voters
```


是的，我喜欢在注释中和自己对话。这提醒我把TODO事项转化为代码，这样没有人不得不读我扭曲的内心独白。



------------------


## 拼错


在我诸多超能力中，编程拼写错误是最靠前的几个。像我在函数中忘记返回值一样，当我专注编程几小时后，又缺少编写或运行测试的时候，我就会犯这个错误。在看起来像快获得编程胜利荣耀时，没有一堆`NameErrors`或者`AttributeErrors`，来打击此人的自负。


transposition相当的令人苦恼，因为很难看出来我做错了什么。糟糕的是，如果错误没有被测试捕获，它很有可能一直逃逸知道代码评估。同事进行代码评估时，可能会跳过它，因为他们知道我在做什么，并且认为（通常太款空大量）我知道我在做什么。


我的手指似乎喜欢折磨我。任何我依赖REST APIs写的端到端的测试都不完备，在缺少至少半打`reponse`实例。我可能想向JSON有效内容中增加一个`metadata`元素，但是已经接近截止时间，我反抗的耻骨拼写了`meatdata`。自从我的手指不配合后，几天后我屈服了，并且谨慎的到处使用`slef`而不是`self`。










